{"id":298579447,"lang":"python3","time":"1Â year, 5Â months","timestamp":1580347061,"status_display":"Accepted","runtime":"84 ms","url":"/submissions/detail/298579447/","is_pending":"Not Pending","title":"Combination Sum","memory":"12.5 MB","code":"import math\n# sort the set in descendent order [big->small]\n# divide and conquer, for each candidate number, create i=1~floor(tar_curr/candi_curr) recurrent problems:\n# sub_problem candidates being list of nums afer candi_curr and tar_curr = tar_curr - i*candi_curr\n# boundary: len(candi_list) == 1, if target_current == some_int*candi_curr, return set[[candi_curr*some_int]]\n# i_th resulting set = add i*candi_curr to each entrie of the subproblem return set\n# resulting set: merge all floor(tar_curr/candi_curr) resulting sets into one set of number sequences\n\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \n# \n#         output = []\n#         def permutate(c, pos, target, answer):\n#             while pos < len(c):\n#                 val: int = target - c[pos]\n#                 if val == 0:\n#                     # Found answer, add it to output\n#                     answer.append(c[pos])\n#                     output.append(answer[:])\n#                     # print(answer)\n#                     # print(output)\n#                     del answer[len(answer) - 1]\n#                     break\n#                 elif val < 0:\n#                     # Breaking out, there is not going to be valid values c[n + 1] > c[n]\n#                     break\n#                 else:\n#                     # Try to recurse with same value from candidates  as val > 0\n#                     answer.append(c[pos])\n#                     permutate(c, pos, val, answer)\n#                     del answer[len(answer) - 1]\n#                 # Go to next index when trying to figure out a valid combination\n#                 pos += 1\n#                 # print(output)\n\n\n#         candidates.sort()\n#         permutate(candidates, 0, target, [])\n#         return output\n            # print(self.output)\n            # return self.output\n#  \n#     def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        results = []\n        if(len(candidates) == 0):\n            return result\n\n        candidates.sort()\n        temp = []\n\n        def dfs(results, candidates, temp, target,index):\n            if target == 0:\n                results.append(temp[:])\n                return\n\n            for i in range(index, len(candidates)):\n                if candidates[i]> target:\n                    break\n\n                temp.append(candidates[i])\n\n                dfs(results, candidates, temp,target-candidates[i], i)\n                temp.pop() #first add the element without caparation\n\n        dfs(results, candidates, temp ,target, 0)\n    \n        return results\n\n# ''' my original solution '''\n#         candidates.sort(reverse = True)\n#         # ans = []\n        \n#         def fn(candi, target) -> [[int]]:\n#             if target == 0:\n#                 return [[]]\n#             elif len(candi) == 1:\n#                 if target % candi[0] == 0:\n#                     ans = [[]]\n#                     for _ in range(math.floor(target / candi[0])):\n#                         ans[0].append(candi[0])\n#                     return ans\n#                 else:\n#                     return [[]]\n#             else:\n#                 ans = [[]]\n#                 for i in range(math.floor(target / candi[0])+1):\n#                     sub_ans = fn(candi[1:], target - i * candi[0])\n#                     # print(sub_ans)\n#                     if sub_ans != [[]]:\n#                         # print(sub_ans)\n#                         for seq in sub_ans:\n#                             for _ in range(i):\n#                                 seq.append(candi[0])\n#                             ans.append(seq)\n#                     elif target == candi[0] * i:\n#                         ans.append([])\n#                         for _ in range(i):\n#                             ans[-1].append(candi[0])\n#                 ans.pop(0)\n     \n#                 return ans\n\n#         ans = fn(candidates, target)\n#         if ans==[[]]:\n#             return []\n#         else:\n#             return ans","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"combination-sum"}