{"id":298052124,"lang":"python3","time":"1Â year, 5Â months","timestamp":1580186925,"status_display":"Accepted","runtime":"40 ms","url":"/submissions/detail/298052124/","is_pending":"Not Pending","title":"Combination Sum II","memory":"12.7 MB","code":"# 134ms\n# class Solution:\n#     def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n#         candidates.sort(reverse=True)\n        \n        \n#         def fn(candi: List[int], target: int) -> List[List[int]]:\n#             if target==0:\n#                 return [[]]\n#             elif target < 0:\n#                 return None\n#             elif len(candi) == 1:\n#                 if target == candi[0]: return [[candi[0]]]\n#                 else: return None\n#             elif len(candi) > 1:\n#                 sub_ans1 = fn(candi[1:], target-candi[0])\n#                 sub_ans2 = fn(candi[1:], target)\n#                 if sub_ans1==None:\n#                     return sub_ans2\n#                 else:\n#                     for _ in sub_ans1:\n#                         _.append(candi[0])\n#                     if sub_ans2 == None:\n#                         return sub_ans1\n#                     else:\n#                         for _ in sub_ans2:\n#                             sub_ans1.append(_)\n#                         return sub_ans1\n        \n#         ans = fn(candidates, target)\n        \n#         if ans == [[]] or ans == None:\n#             return []\n#         else:\n#             i = 0\n#             while (i < (len(ans)-1)):\n#                 j = i +1\n#                 while(j<len(ans)):\n#                     if ans[j] == ans[i]:\n#                         ans.pop(j)\n#                     else:\n#                         j = j + 1\n#                 i = i+1\n#             return ans\n\n# 44ms\n# class Solution:\n#     def combinationSum2(self, C: List[int], t: int) -> List[List[int]]:\n#         L, A, _ = len(C), [], C.sort()                          \n#         def dfs(I, P, S):\n#             if S == t: return A.append(P)\n#             for i in range(I,L):\n#                 if i > I and C[i] == C[i - 1]: continue\n#                 if S + C[i] > t: break\n#                 dfs(i + 1, P + [C[i]], S + C[i])\n#         dfs(0, [], 0)\n#         return A\n\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \n        candidates.sort()\n        \n        def fn(nums, x, i=0):\n            \"\"\"backtracking algorithm\"\"\"\n            for k in range(i, len(candidates)): \n                if k > i and candidates[k] == candidates[k-1]: continue #break repetition \n                if candidates[k] > x: break \n                elif candidates[k] == x: ans.append(nums + [candidates[k]])\n                else: fn(nums + [candidates[k]], x - candidates[k], k+1) #break repetition\n        \n        ans = []\n        fn([], target)\n        return ans ","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"combination-sum-ii"}