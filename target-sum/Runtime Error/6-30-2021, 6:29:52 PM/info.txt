{"id":515577671,"lang":"python3","time":"3Â weeks","timestamp":1625092192,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/515577671/","is_pending":"Not Pending","title":"Target Sum","memory":"N/A","code":"class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        \n        # DFS: recursion with memoization\n        # is it true that all dynamic programming can be \n        #   implemented via recursion with memoization?\n        \n        mem = []\n        for i in range(len(nums)):\n            mem.append([float(\"inf\")] * 2001)\n        for i in range(2001):\n            mem[0][i] = 0\n        mem[0][nums[0] + 1000] += 1\n        mem[0][-nums[0] + 1000] += 1\n        # mem[i][s+1000]: ways of nums[0:i+1] summing to s\n        \n        def rec(i: int, s: int) -> int:\n            # recursive func\n            # rec(i, s) = mem[i][s]\n            nonlocal mem\n            # print(\"recur\")\n            # print(i)\n            # print(s)\n            if i == 0:\n                # print(\"return \" + str(mem[0][s+1000]))\n                return mem[0][s+1000]\n            if s < -1000 or s > 1000:\n                # print(\"return 0\")\n                return 0\n            if mem[i][s+1000] != float(\"inf\"):\n                # print(\"return \" + str(mem[i][s+1000]))\n                return mem[i][s+1000]\n            mem[i][s+1000] = rec(i-1, s - nums[i]) + rec(i-1, s + nums[i])\n            # print(\"return \" + str(mem[i][s+1000]))\n            # nums[0: i-1] sum to \"s +- nums[i]\"\n            return mem[i][s+1000]\n        \n        return rec(len(nums)-1, target)\n        \n        \n#         # didn't do this problem, asked Qi for answers\n#         # notice 0 <= sum(nums[i]) <= 1000, meaning the possible sums induced\n#         #   from adding \"+\"/\"-\" before each num is within range(-1000, 1001)\n#         #   calculate all possibilities using dynamic programming\n        \n#         dp = [0] * 2001\n#         dp[1000] = 1\n#         # dp_i:= [-1000, ..., 0, ..., 1000]\n#         # update the array \"dp\" 20 rounds\n#         # the i_th round: dp[j-1000] \n#         #   meaning ways of summing up to (j-1000) using the first i nums\n        \n#         for num in nums:\n#             temp_plus = [0] * 2001\n#             temp_minus = [0] * 2001\n#             for i in range(num, 2001):\n#                 temp_plus[i] = dp[i-num]\n#             for i in range(0, 2001 - num):\n#                 temp_minus[i] = dp[i+num]\n#             for i in range(2001):\n#                 dp[i] = temp_plus[i] + temp_minus[i]\n        \n#         return dp[target+1000]\n    ","compare_result":"111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"target-sum"}