{"id":504596449,"lang":"python3","time":"1 month, 2 weeks","timestamp":1623099752,"status_display":"Accepted","runtime":"340 ms","url":"/submissions/detail/504596449/","is_pending":"Not Pending","title":"Serialize and Deserialize Binary Tree","memory":"19.2 MB","code":"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\"\"\"\nTo map a recursive structure like a tree to a linear object of a string,\nthere are many ways.\nTo reconstruct a recursive structure (tree) from a linear object of a string,\nunless we have predefined the meaning of each coordinate of string, \n(the leetCode serialization, filling up with Null), \nreconstruction with one pass of the string is impossible.\n\nXXXXXX Above is wrong! XXXXXX\nThen what the heck happened with given only preorder, cannot decide tree structure?\nRecursive deserialization, when calls 'root.right(l)', the left tree has already been processed, hence the left description string is consumed already\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nQi's idea:\nExample1:  \"1(2,3(4,5))\"\nfinding substrings for subtrees will make time complexity O(n* log n)\nreconstruction: find deviding point, recursively construct with substring\n\nTia's idea:\nExample1: \"1l2lnrnbr3l4lnrnbr5lnrnbbb\"\nrecording the full trace of a recursive traversal of tree\nwhich uniquely defines a tree.\nreconstruction: use a loop to reconstruct with the trace of traversal\n\"\"\"\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        res = []\n        def recur(root: TreeNode):\n            if root == None:\n                res.append('n') # 'None'\n                return\n            res.append(str(root.val))\n            res.append('l')  # 'Left'\n            recur(root.left)\n            res.append('r')  # 'Right'\n            recur(root.right)\n            res.append('b')  # 'Back'\n            return\n        \n        recur(root)\n        rString = \"\"\n        for ele in res:\n            rString = rString + ele\n        \n        return rString\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        # print(data)\n        data = list(data)\n        \n        # print(data)\n        \n        global curr\n        curr = 0\n        \n        def getEle() -> str:\n            global curr\n            if data[curr] == 'n':\n                curr += 1\n                return 'n'\n            if data[curr] == 'l':\n                curr += 1\n                return 'l'\n            if data[curr] == 'r':\n                curr += 1\n                return 'r'\n            if data[curr] == 'b':\n                curr += 1\n                return 'b'\n            \n            # read a number, move curr index to the next non-digit position\n            num = ''\n            # print(curr)\n            # print(data[curr])\n            if data[curr] == '-':\n                num = num + data[curr]\n                curr += 1\n            while(data[curr].isnumeric()):\n                num = num + data[curr]\n                curr += 1\n            # print(num)\n            return num\n        \n        \n        if data[0] == 'n':\n            return None\n        \n        stack = []\n        root = TreeNode(int(getEle()))\n        \n        stack.append(root)\n        node = root\n        # initialize start node and recurrence stack\n        \n        while(curr < len(data)):\n            s = getEle()\n            # get the next action, s means \"symbol\"\n            if s == 'l':\n                ele = getEle()\n                if ele == 'n':\n                    continue\n                else:\n                    node.left = TreeNode(int(ele))\n                    stack.append(node)\n                    node = node.left\n            if s == 'r':\n                ele = getEle()\n                if ele == 'n':\n                    continue\n                else:\n                    node.right = TreeNode(int(ele))\n                    stack.append(node)\n                    node = node.right\n            if s == 'b':\n                node = stack.pop(-1)\n        \n        \n        return root\n        \n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))","compare_result":"1111111111111111111111111111111111111111111111111111","title_slug":"serialize-and-deserialize-binary-tree"}