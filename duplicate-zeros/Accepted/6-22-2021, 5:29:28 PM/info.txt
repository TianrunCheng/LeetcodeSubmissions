{"id":511778227,"lang":"python3","time":"4 weeks, 1 day","timestamp":1624397368,"status_display":"Accepted","runtime":"68 ms","url":"/submissions/detail/511778227/","is_pending":"Not Pending","title":"Duplicate Zeros","memory":"14.7 MB","code":"class Solution:\n    def duplicateZeros(self, arr: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify arr in-place instead.\n        \"\"\"\n#         n = len(arr)\n#         i = 0\n#         while(i < n):\n#             if arr[i] == 0:\n#                 for j in range(n-2, i-1, -1):\n#                     arr[j+1] = arr[j]\n#                 i += 1\n#             i += 1\n        \n#         return\n\n\n#         # find out how many elements are pushed out of edge\n#         n = len(arr)\n#         first_discard = n\n#         # first_discard initialized as arr[n]\n#         used_len = 0\n        \n#         # traverse the arr, remember curr_len of the travelled array\n#         # - after duplicating zeros\n#         for i in range(n):\n#             if used_len >= n:\n#                 first_discard = i\n#                 print(used_len)\n#                 print(first_discard)\n#                 break\n            \n#             if arr[i] == 0:\n#                 used_len += 2\n#             else:\n#                 used_len += 1\n        \n#         left = first_discard - 1\n#         right = used_len - 1\n#         while(right > left):\n#             print(left)\n#             print(right)\n#             # print(arr)\n#             if arr[left] == 0:\n#                 if right < n:\n#                     arr[right] = 0\n#                     right -= 1\n#                     arr[right] = 0\n#                     right -= 1\n#                     left -= 1\n#                 else:\n#                     right -= 1\n#                     arr[right] = arr[left]\n#                     left -= 1\n#                     right -= 1\n                    \n#             else:\n#                 arr[right] = arr[left]\n#                 right -= 1\n#                 left -= 1\n                \n#         return\n\n\n        possible_dups = 0\n        length_ = len(arr) - 1\n\n        # Find the number of zeros to be duplicated\n        for left in range(length_ + 1):\n\n            # Stop when left points beyond the last element in the original list\n            # which would be part of the modified list\n            if left > length_ - possible_dups:\n                break\n\n            # Count the zeros\n            if arr[left] == 0:\n                # Edge case: This zero can't be duplicated. We have no more space,\n                # as left is pointing to the last element which could be included  \n                if left == length_ - possible_dups:\n                    arr[length_] = 0 # For this zero we just copy it without duplication.\n                    length_ -= 1\n                    break\n                possible_dups += 1\n\n        # Start backwards from the last element which would be part of new list.\n        last = length_ - possible_dups\n\n        # Copy zero twice, and non zero once.\n        for i in range(last, -1, -1):\n            if arr[i] == 0:\n                arr[i + possible_dups] = 0\n                possible_dups -= 1\n                arr[i + possible_dups] = 0\n            else:\n                arr[i + possible_dups] = arr[i]\n        ","compare_result":"111111111111111111111111111111","title_slug":"duplicate-zeros"}