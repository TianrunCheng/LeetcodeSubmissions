{"id":519606317,"lang":"python3","time":"1 week, 5 days","timestamp":1625803223,"status_display":"Accepted","runtime":"100 ms","url":"/submissions/detail/519606317/","is_pending":"Not Pending","title":"Unique Binary Search Trees II","memory":"16 MB","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        \n        def build(start: int, end: int):\n            # a generator of all binary trees storing vals between [start: end]\n            \n            if start > end:\n                yield None\n                # return\n                # return [None,]\n            \n            # res = []\n            for i in range(start, end+1):\n                # left tree [start, i-1], right tree [i+1, end]\n                for l in build(start, i-1):\n                    # print(l)\n                    for r in build(i+1, end):\n                        # print(r)\n                        root = TreeNode(i)\n                        root.left, root.right = l, r\n                        yield root\n            #             res.append(temp)\n            # return res\n        \n        res = []\n        iter_obj = build(1, n)\n        \n        for ele in iter_obj:\n            res.append(ele)\n        \n        return res\n        # return build(1, n) if n else []\n        # #   # \"if n else []\" saves a lot of runtime, why?","compare_result":"11111111","title_slug":"unique-binary-search-trees-ii"}